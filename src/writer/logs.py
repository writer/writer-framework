import io
import logging
import time
from contextlib import contextmanager
from functools import wraps
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from writer.core import WriterState


def _add_routing_key(routing_key: int):
    """
    A decorator to add a `routing_key` to the `extra` dict for the logging calls.

    :param routing_key: The routing key to be added to the log record.
    """
    def inner(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            if "extra" not in kwargs:
                kwargs["extra"] = {}
            kwargs["extra"]["routing_key"] = routing_key
            return func(self, *args, **kwargs)
        return wrapper
    return inner


class RoutingKeyFilter(logging.Filter):
    """
    A logging filter that allows log records to be filtered based on a routing key.
    
    The filter compares the `routing_key` attribute of the log record with the routing key
    passed during initialization.

    :param routing_key: The routing key to be added to the log record.
    """
    def __init__(self, routing_key: int):
        self._routing_key = routing_key

    def filter(self, record):
        if hasattr(record, "routing_key"):
            return record.routing_key == self._routing_key
        return False


class LoggerProxy:
    """
    A proxy class that wraps around a logger instance and modifies its behavior
    by adding a routing key to log records for logging methods (`debug`, `info`, etc.)

    :param target_logger: The logger instance being proxied.
    """
    def __init__(self, target_logger: logging.Logger):
        self._target_logger = target_logger
        self.routing_key = time.monotonic_ns()

    def __getattr__(self, attr):
        attr_value = getattr(self._target_logger, attr)
        if attr in ("debug", "info", "warning", "warn", "error", "exception", "critical"):
            attr_value = _add_routing_key(self.routing_key)(attr_value)
        return attr_value

    def __setattr__(self, attr, value):
        if attr in ["_target_logger", "routing_key"]:
            super().__setattr__(attr, value)
        else:
            setattr(self._target_logger, attr, value)


@contextmanager
def capture_logs(logger: logging.Logger, session_state: Optional["WriterState"] = None, buffer: Optional[io.StringIO] = None):
    """
    Context manager that captures logs generated by the specified logger and stores them in a buffer.

    This context manager allows logs to be captured, filtered by a routing key, and optionally
    added to a session state.

    :param logger: The logger whose logs are to be captured.
    :param session_state: An optional state object where captured logs can be stored.
    :param buffer: A buffer to capture the logs. If not provided, a new buffer will be created.

    :yields: A proxy object for the logger that captures logs with a routing key.
    """
    if buffer is None:
        buffer = io.StringIO()

    original_propagate = logger.propagate
    logger.propagate = False
    logger_proxy = LoggerProxy(logger)
    handler = logging.StreamHandler(buffer)
    handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
    handler.addFilter(RoutingKeyFilter(routing_key=logger_proxy.routing_key))
    logger.addHandler(handler)

    try:
        yield logger_proxy
    finally:
        logger.removeHandler(handler)
        handler.close()
        captured_logs = handler.stream.getvalue()
        if session_state is not None and captured_logs:
            session_state.add_log_entry("info", "Captured logs", captured_logs)
        logger.propagate = original_propagate
